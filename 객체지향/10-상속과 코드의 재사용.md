# 상속과 코드 재사용

## 배경
객체지향 프로그래밍의 장점 중 하나는 코드의 재사용성이 좋다라는 것이다.
왜냐? 클래스로 모듈와, 클래스간의 상속, 다형성 을 통해서 재사용이 가능하기 때문이지~
객체지향에서 코드 재사용 방법으로는 새로운 클래스를 추가하는 것이다.
이는 상속과 합성으로 나뉠 수 있다.
`상속`: 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법
`합성`: 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스로 포함시키는 방법

## 상속과 중복코드
중복코드는 코드에 대한 신뢰성을 낮추기 때문에 제거 대상이지.
왜냐? 변경에 취약해지기 때문, 변경에 대응하기 위해 중복된 코드를 모두 변경해줘야하는데 이를 위해 모든 중복 코드에 대한 검증이 필요하게 되는데
이때 모든 중복 코드에 대한 테스트가 필요해지기 때문에.

### DIY(Don't Repeat Yourself) 원칙
> 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야한다.

DIY 원칙의 핵임은 코드 안에 중복이 존재해서는 안 된다라는 것이다.
여기서 중복 여부를 판단하는 기준은 변경이며, 이 말은 `요구사항의 변경`에 두 코드가 `동시에 수정`되어야한다면 `중복 코드로 판단`한다라는 뜻이다.

> 중복 여부를 판단하는 기준은 `변경에 반응`하는 방식이다.
> 모양이 유사하다면 중복 코드의 징후이다.

### 중복과 변경
중복 코드를 제거하지 않고 변경에 대응하는 유일한 방법은 새로운 중복 코드를 추가하는 방법 뿐이다. (악순환)
또한 타입 코드(클래스의 멤버 변수로 type을 저장하고 분기처리하는)를 사용하는 클래스 또한 중복을 제거를 위한 방식으로 종종 사용되는데
이 방법은 낮은 응집도와 높은 결합도라는 문제를 낳는다.
왜냐? 타입 코드 값에 따라 클래스의 동작이 달라지므로 하나의 클래스에 두개의 책임이 할당되고, 타입이 필수적이게 됨으로 타입(타입을 결정해주는 무언가?)와 결합도가 높아질수밖에 없기때문이지, 부가적으로 타입 세팅문제(잘못된 값을 넣을수도있고), 객체의 타입을 검사하기 위해 if문이 들어갈수밖에 없다라는 문제가 있다.

### 상속을 이용해서 중복코드 제거하기
중복 코드를 관리하는 방법 중 하나로 `상속`을 사용한다.
하지만 상속을 통한 코드의 재사용은 설계의 트레이드오프를 발생시킨다.
그것은 바로 코드의 재사용성을 위해 캡슐화를 포기해야된다는것이다.

상속은 부모클래스와 자식클래스간의 강한 결합을 발생시킨다.
이유는 무엇인가?
부모클래스를 개발한 개발자의 의도(내부 구현)을 명확하게 인지해야된다. 
자식 클래스에서 super키워드로 부모의 메소드를 호출할경우 그 영향도는 더 커진다.

## 취약한 기반 클래스 문제(Fragile Base Class Promblem, Brittle Base Class Problem)
상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 `취약한 기반 클래스 문제`라고 부른다.
이 문제는 캡슐화를 약화시키고 결합도를 높인다.
왜냐? 자식 클래스가 부모 클래스의 구현 세무사항에 의존하도록 만들기 때문에

> 취약한 기반 클래스 문제는 상속이라는 문맥안에서 결합도가 초래하는 문제점을 말한다.
> 객체지향의 기반든 캡슐화를 통한 변경의 통제인데, 상속은 캡슐화의 장점을 희석시킨다.

### 불필요한 인터페이스 상속 문제
부모의 인터페이스가 자식 클래스에서도 노출된다.
따라서 부모클래스의 인터페이스가 자식 클래스의 내부 구조에 대한 규칙을 깨버릴수 있다.(stack, vector 상속 문제)

### 메서드 오버라이딩의 오작용 문제
자식 클래스가 부모 클래스를 오버라이딩할 경우 부모 클래스가 메소드를 사용하는 방식에 따라 버그가 발생할 가능성이 있다.
예)HashMap에서 add, addAll에서 내부적으로 addAll이 add를 호출한다 라는 것을 모르고 오버라이딩해서 사용했을 경우

### 부모 클래스와 자식 클래스의 동시 수정 문제
부모 클래스의 구현의 변경에 따라 자식 클래스가 같이 수정되어야 하는 문제점이 있다.
이는 중복 코드의 기준을 생각보았을때 코드 재사용성을 위해 상속을 사용했음에도 불구하고 중복코드의 특성을 갖고 있다.

## 상속으로 인한 피해를 최소하는 방법
취약한 기반 클래스 문제를 완전히 없앨 수 없지만, 추상화를 통해 어느 정도 완화는 가능하다.

### 추상화에 의존하자
의존성 관리에서 의존성의 방향은 모두 추상화에 의존해야된다고 했다.
그렇게 하자 ㅋㅋ

추상화로 중복 코드를 제거하기 위한 2가지 원칙을 살펴보자
> 1.차이를 메서드로 추출하라, 유사한 두 메서드의 차이점을 추출하고, 두 메서드를 동일한 형태로 보이게끔 만든다.
> 2.중복코드를 부모 클래스로 올려라, 부모 클래스의 코드를 자식 클래스로 내리지말고, 자식클래스의 코드를 부모 클래스로 올리자

### 차이를 메서드로 추출하라
중복 코드 안에서 `차이점`을 별도 메서드로 분리한다.
그리고 이 둘을 동일한 형태(같은 인터페이스)로 보이게 만든다.

> "변하는 것으로부터 변하지 않는 것을 분리하라", "변하는 부분을 찾고 이를 캡슐화 하라" 의 메서드 수준의 적용

### 중복 코드를 부모 클래스로 올려라
`1.차이를 메서드로 추출하라`가 완료 되었으면, 두 클래스는 공통된 부분과 같은 인터페이스 갖지만 다른 책임을 갖는 메서드가 있을 것이다.
이제 공통된 부분을 제거해야되는데 이때 `추상화`를 통해서 제거하도록 한다.
방법은 공통된 부분을 구현한 abstract 클래스를 만들고 같은 인터페이를 갖지만 다른 책임을 갖고 있는 메서드를 이용할 수 있게 해당 인터페이스를 갖는 추상 메서드를 만든다. 
이 후 기존 두 클래스에서 공통된 부분을 삭제하고 새롭게 만든 추상 클래스를 상속 받도록 한다.

이렇게 함으로서 모든 의존성을 추상화를 바라보도록 되어있고, 각 클래스는 자신이 맡은 책임만 갖게 되었다.

> 1,2를 정리하자면, 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.

### 차이에 의한 프로그래밍(Programming by difference)
이렇게 중복 코드를 제거하면서 새로운 기능을 새로운 클래스만 추가하면서 확장하는 방법을
`차이에 의한 프로그래밍`이라고 한다.
결국 목표는 중복 코드를 제거하고 코드이 재사용성을 높이는것이다.

> 차이에 의한 프로그래밍: 기존 코드와 다른와 다른 부분만 추가함으로써 애플리케이션의 기능을 확장하는 방법이다.

## 정리
추상화에 의존하도록 의존성 방향을 바꿈으로서 상속으로 인한 문제점을 어느정도 해결할 수 있지만,
부모의 인스턴스가 변경되는 상황에서는 생성자에서 초기화 해줘야하는 로직이 변경되기 때문에 자식 클래스의 수정이 불가피하게 된다.
그렇지만 객체 생성에 대한 대응은 factory, 등 다양한 대응법이 존재하기 때문에, 최대한 핵심 비지니스 로직의 중복을 막아야한다.

> 클래스라는 메서드뿐만 아니라 인스턴스 변수도 함께 포함하고 있다. 이는 클래스 사이의 상속은 행동(메서드)뿐만 아니라, 인스턴스 변수에서도 결합되게 만든다.
> 핵심 로직은 한 곳에 모아 놓고 캡슐화해야된다. 그리고 공통적인 핵심 로직은 최대한 추상화해야된다.

상속으로 인한 단점은 `합성`을 통해서 해결할 수 있다.