# 유연한 설계

## 배경
의존성 관리에 대한 설계원칙에 대한 내용을 다루며, 설계를 할 때 공통적인 용어를 익힌다는 방향으로 정리한다.

## 개방-폐쇄원칙(Open-Closed Principle, OCP)
로버트 마틴이 고안한 개방-패쇄원칙이라는 것이 있다.
> 소프트웨어 개체(클래스, 모듈, 함수 등)는 `확장`에 열려있고, `수정`에 대해서는 닫혀 있어야한다.

여기서 `확장`과 `수정`의 단어의 의미를 더 자세히 살펴보면,
확장은 애플리케이션의 기능, 동작의 추가를 의미하며, 수정은 기존 코드에 대한 변경을 의미한다.
즉 기존 코드의 변경없이 새로운 기능을 확장할 수 있어야한다는 뜻이다.

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
개방-폐쇄원칙을 의존성의 관점에서 보면 컴파일 타임의 의존성을 변경하지 말고 런타임시 의존성을 변경시키라는 말과 같다.
이를 가능케하기 위해서는 `추상화`를 이용해야된다.
추상화를 통해 컴파일 타임의 의존성을 고정시키고, 런타임시 추상화의 구현체를 주입시킴으로서 기능을 확장시켜야 한다.

### 추상화가 핵심이다.
`추상화`을 자세히 정의하자면
> 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.
> 추상화 과정을 거치면, 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다. 따라서 생략된 부분은 문맥에 따라 채워넣음으로써 기능을 구체화하고 확장할 수 있다.

여기서 주의할 점은 단순히 추상화를 했다고 해서 개방-폐쇄원칙을 따르는 코드를 작성할 수 없다.
추가적으로 `모든 요소가 추상화에 의존`하도록 해야된다.
이 말의 뜻은 추상화 대상을 이용한 코드가 또 다른 구체화된 클래스에 의존하도록 되어있다면 아무리 추상화를 하더라도 기능 확장을 위해 구체화된 클래스까지 수정에 영향이 갈 수 있기 때문이다.

> 변경에 의한 사이드 이펙트를 최소화 하기 위해서는 올바른 추상화가 필수이다.
> 올바른 추상화는 변하는것과 불변하는것을 명확히 인지하는것 부터 시작이다.
> 추상화에 대해서만 의존하도록 관계를 제한해야된다.

## 생성 사용 분리
객체를 사용하는 쪽에서 생성하게 된다면 기능 확장시 기존 코드의 수정이 들어가기 때문에 개방-폐쇄원칙에 어긋나게 된다.
문제는 객체를 생성하는게 아닌, 생성하는 위치가 문제이다.
> 즉 동일한 객체 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제이다.

객체의 `생성`과 `사용`에 대한 책임을 서로 다른 객체에게 분리해야되며, 생성에 대한 책임은 객체를 사용하는 `클라이언트`가 갖고 있어야한다.

> 애플리케이션은 (객체를 제작하고 의존성을 서로 연결하는)시작 단계와 (시작 단계 이후 이어지는) 실행 단계를 분리해야된다.[Martin08]

### Factory 추가하기
객체 생성에 특화된 클래스는 Factory라고 부른다.
클라이언트는 사용할 객체를 생성해주는 Factory를 통해서 객체를 생성하여 사용한다.
즉 클라이언트는 `생성`의 책임이 사라지고 오직 `사용`의 책임만 남게된다.

> 객체생성 책임을 담당할 객체가 없다면 FACTORY를 고려해라

### 순수한 가공물(Pure Facbrication)에 책임 할당하기
객체의 책임을 할당하기 위해서 먼저 도메인 모델에서 `INFORMATION EXPERT(5장 참고)` 원칙에 적합한 객체를 찾아 책임을 할당한다.
하지만 위에서 설명한 `FCATORY`는 도메인 모델에서 존재하지 않는다.
즉 도메인 모델에 없는 존재에게 생성의 책임을 할당한것이다.

왜 이런 일이 벌어지는가?? => 모든 책임을 도메인 객체에게만 할당하게 된다면 유연한 설계의 원칙들을 따를수없는 상황이 생길수 있으며, 도메인 개념을 초월한 데이터베이스, 네트워크와 같은 기계적 개념을 포함하여 설계하기가 어렵기 때문이다.
이러한 결과로 PURE FACBRICATION을 추가하며, 이것은 보통 `특정한 행동`을 표현하는 것이 일반적이다.
여기서 말하는 `특정한 행동`은 표면적으로 들어나는(도메인 모델의 개념)이 아닌 객체를 생성한다. 데이터 베이스에 연결한다. 등의 행위적 개념이다.

> 객체지향 애플리케이션은 도메인 개념뿐만 아니라 인공적인 추상화들도 포함하고 있다.  (실세계의 모방이라는 말은 옳지 않다.)
> 도메인 추상화를 기반으로 설계하는 동시에 품질의 측면에서 균형을 맞추는데 필요한 객체들을 창조하라

## 의존성 주입(Dependency Injection DI)
객체의 생성과 사용을 분리함에 따라 생성된 객체를 사용하는 클라이언트로 넘겨줘야한다.
이처럼 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 한다.
의존성 주입은 가급적 퍼블릭 인터페이스에 노출되어 명시적으로 의존성을 파악할 수 있게해야된다.
하지만 로그와 같이 여러 계층에서 공통으로 사용하거나 인터페이스에 명시되면 안될것을은 전역객체를 사용하는것도 나쁘지 않음

> 명시적인 의존성 주입은 애플리케이션의 유연성을 높이준다.

## 의존성 역전 원칙(Dependency Invertion Principle DIP)
### 추상화와 의존성 역전
객체 사이의 협력이 존재할때 상위/하위 수준의 클래스로 나눠볼 수 있다.
협력의 목표를 생각하였을때 상위 수준 클래스는 협력의 목표를 당성하기 위해 중요한 결정을 갖고 있는 것이며,
하위 수준 클래스는 상위 수준의 비지니스 로직에 필요한 구성 요소 중 하나로 볼 수 있다.

이러한 협력 관계에서 하위 수준의 변경이 상위 수준의 클래스에 영향이 있다면 `의존성의 방향`에 문제가 있음을 의심해야된다.
이 경우에도 해결 방법은 `추상화`이며 모든 상위/하위 수준의 클래스 모두 `추상화`에 의존 하도록 해야된다.

> 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야한다.
> 구체 클래스는 의존성의 목적지가 아닌 출발지여야한다.

`의존성 역전 원칙`에서 `역전`이라는 단어의 의미는 보통 상위 클래스에서 하위 클래스의 메소드를 호출하는 경우 상위 클래스가 하위 클래스의 인터페이스에 맞춰준다.
즉 A가 B의 bm이라는 인터페이스를 호출하는 것이니 A가 B의 인터페이스에 맞춰준 것이다. 다시 말해서 서비스를 사용하는 쪽(A 클래스)가 제공하는 쪽(B클래스)의 인터페이스에 맞춤
여기서 의존성 역전 원칙을 지키는 코드라면 A가 B를 사용하기 위해서 B가 A가 사용하는 인터페이스에 맞춰 구현해야된다.
여기서 A와 B의 상황이 `역전` 되었기 때문에 `의존성 역전` 이라고 한다.

### 의존성 역전 원칙과 패키지
보통 추상화 클래스와 추상화 클래스를 구체화한 클래스를 하나의 독립적인 패키지 안에 묶어서 사용할 것이다.
하지만 SEPARATE INTERFACE 패턴에 따르면 추상화를 독립적인 패키지가 아닌 클라이언트(해당 추상화를 사용하는 클래스)가 속한 패키지에 포함시켜야 한다고 한다.
왜냐? 추상화와 추상화의 구체클래스가 하나의 패키지에 있다면 추상화를 사용하는 클라이언트의 재사용성이 구체화된 클래스의 문맥에 제한이 된다거나, 필요없는 클래스까지 같이 포함 시켜야되는 상황이 올 수 있다.

> 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재상요하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.
> 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다.

## 마무리
> 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.
> 즉 역할, 책임, 협력에 먼저 집중하고 객체의 생성 방법에 대한 결정은 모든 책임이 자리를 잡은 후 마지막에 결정하는것이 좋다.